# 第3章：光栅化

## 章节概述

光栅化是将连续的几何图元转换为离散像素的过程，是现代实时渲染的核心技术。本章深入探讨光栅化的数学原理、算法实现和硬件优化策略。我们将从三角形的离散化开始，逐步深入到深度测试、抗锯齿技术，最后探讨现代GPU的光栅化管线设计。通过本章学习，读者将掌握从几何到像素的完整转换过程，理解现代图形硬件的设计哲学，并能够分析和优化光栅化性能。

## 3.1 三角形的离散化

### 3.1.1 为什么选择三角形

三角形是计算机图形学中最基本的图元，其优势包括：
- **平面性保证**：三个不共线的点唯一确定一个平面
- **凸性质**：三角形必定是凸多边形，简化了内外判断
- **插值简单**：重心坐标提供了自然的线性插值框架
- **硬件友好**：固定的顶点数量便于并行处理

### 3.1.2 三角形的表示

三角形可以通过三个顶点 $\mathbf{v}_0, \mathbf{v}_1, \mathbf{v}_2$ 表示，每个顶点包含：
- 位置：$\mathbf{p} = (x, y, z, w)^T$（齐次坐标）
- 属性：颜色、法线、纹理坐标等

在屏幕空间中，经过投影变换后的顶点坐标为：
$$\mathbf{p}_{\text{screen}} = \begin{pmatrix} x_s \\ y_s \\ z_s \end{pmatrix} = \begin{pmatrix} \frac{x_{ndc} + 1}{2} \cdot \text{width} \\ \frac{y_{ndc} + 1}{2} \cdot \text{height} \\ z_{ndc} \end{pmatrix}$$

### 3.1.3 点在三角形内的判断

#### 叉积法（Edge Function）

对于屏幕空间中的点 $\mathbf{p} = (x, y)$，判断其是否在三角形内部最常用的方法是边函数（edge function）：

$$E_{01}(\mathbf{p}) = (x - x_0)(y_1 - y_0) - (y - y_0)(x_1 - x_0)$$

点 $\mathbf{p}$ 在三角形内部当且仅当：
- $E_{01}(\mathbf{p}) \geq 0$
- $E_{12}(\mathbf{p}) \geq 0$  
- $E_{20}(\mathbf{p}) \geq 0$

（假设三角形顶点按逆时针顺序排列）

#### 重心坐标（Barycentric Coordinates）

重心坐标 $(\alpha, \beta, \gamma)$ 定义了点相对于三角形的位置：
$$\mathbf{p} = \alpha \mathbf{v}_0 + \beta \mathbf{v}_1 + \gamma \mathbf{v}_2$$

其中 $\alpha + \beta + \gamma = 1$。计算公式为：
$$\alpha = \frac{E_{12}(\mathbf{p})}{E_{12}(\mathbf{v}_0)}$$
$$\beta = \frac{E_{20}(\mathbf{p})}{E_{20}(\mathbf{v}_1)}$$
$$\gamma = \frac{E_{01}(\mathbf{p})}{E_{01}(\mathbf{v}_2)}$$

点在三角形内部当且仅当 $\alpha, \beta, \gamma \geq 0$。

### 3.1.4 光栅化算法

#### 包围盒算法（Bounding Box）

最简单的光栅化算法：
1. 计算三角形的轴对齐包围盒（AABB）
2. 遍历包围盒内的所有像素
3. 对每个像素进行内外测试

```
xmin = floor(min(x0, x1, x2))
xmax = ceil(max(x0, x1, x2))
ymin = floor(min(y0, y1, y2))
ymax = ceil(max(y0, y1, y2))

for y in [ymin, ymax]:
    for x in [xmin, xmax]:
        if (x, y) inside triangle:
            shade_pixel(x, y)
```

#### 增量算法（Incremental Algorithm）

边函数具有线性性质：
$$E(x+1, y) = E(x, y) + (y_1 - y_0)$$
$$E(x, y+1) = E(x, y) - (x_1 - x_0)$$

利用这一性质可以避免重复计算：
1. 计算起始点的边函数值
2. 使用增量更新相邻像素的值
3. 减少乘法运算，提高效率

#### 分块光栅化（Tiled Rasterization）

现代GPU采用分块策略：
1. 将屏幕划分为固定大小的块（如8×8或16×16）
2. 首先进行块级别的粗测试
3. 只对可能相交的块进行像素级测试

### 3.1.5 亚像素精度与定点数

为避免浮点误差导致的裂缝，现代光栅化器使用定点数表示：
- 典型精度：16.8或24.8格式
- 子像素精度：1/256像素
- 保证相邻三角形的边界精确对齐

定点数转换：
$$x_{fixed} = \lfloor x_{float} \times 2^{subpixel\_bits} + 0.5 \rfloor$$

### 3.1.6 属性插值

对于三角形内部的点，所有顶点属性需要进行插值：

#### 透视正确插值

屏幕空间的线性插值不等于世界空间的线性插值。透视正确插值公式：
$$\frac{1}{w} = \frac{\alpha}{w_0} + \frac{\beta}{w_1} + \frac{\gamma}{w_2}$$
$$attribute = \frac{\frac{\alpha \cdot attr_0}{w_0} + \frac{\beta \cdot attr_1}{w_1} + \frac{\gamma \cdot attr_2}{w_2}}{\frac{1}{w}}$$

其中 $w$ 是齐次坐标的第四分量。

## 3.2 深度测试与抗锯齿

### 3.2.1 深度缓冲（Z-Buffer）

深度缓冲是解决可见性问题的标准方法：
- 为每个像素存储当前最近的深度值
- 新片段只有在更近时才会更新

深度测试算法：
```
for each fragment at (x, y) with depth z:
    if z < depth_buffer[x][y]:
        depth_buffer[x][y] = z
        color_buffer[x][y] = fragment_color
```

#### 深度精度问题

透视投影后的深度分布是非线性的：
$$z_{ndc} = \frac{f+n}{f-n} + \frac{2fn}{f-n} \cdot \frac{1}{z_{eye}}$$

这导致：
- 近处精度高，远处精度低
- Z-fighting：深度值接近时的闪烁

解决方案：
1. **对数深度缓冲**：$z_{log} = \frac{\log(z/n)}{\log(f/n)}$
2. **反向Z**：使用 $1-z$ 作为深度值，配合浮点数格式
3. **多级深度缓冲**：为不同距离范围使用独立的深度缓冲

### 3.2.2 早期深度测试（Early Z）

现代GPU在片段着色前进行深度测试：
- 减少无用的片段着色计算
- 要求深度写入是单调的
- 某些操作会禁用Early Z（如discard、深度修改）

### 3.2.3 层次深度缓冲（Hierarchical Z）

使用深度金字塔加速剔除：
- 存储块级别的最大/最小深度
- 快速剔除被遮挡的大块区域
- 与分块光栅化配合使用

### 3.2.4 抗锯齿基础理论

#### 采样理论

根据奈奎斯特定理，采样频率必须大于信号最高频率的两倍。图形学中的锯齿本质是采样不足导致的混叠。

#### 预滤波vs后滤波

1. **预滤波**：在采样前去除高频成分
2. **后滤波**：对采样结果进行重建

理想的抗锯齿是预滤波，但计算成本高。

### 3.2.5 超采样抗锯齿（SSAA）

最直接的抗锯齿方法：
- 以更高分辨率渲染
- 对结果进行下采样

计算成本：$O(n^2)$，其中 $n$ 是超采样倍数。

### 3.2.6 多重采样抗锯齿（MSAA）

MSAA优化了SSAA的性能：
1. 每个像素存储多个采样点
2. 片段着色只执行一次
3. 深度和覆盖测试对每个采样点独立进行

采样模式：
- 2×MSAA：旋转网格模式
- 4×MSAA：旋转盒模式或Quincunx
- 8×MSAA：优化的Poisson分布

覆盖计算：
```
coverage = 0
for each sample in pixel:
    if sample inside triangle:
        coverage += 1/num_samples
final_color = coverage * fragment_color + (1-coverage) * background
```

### 3.2.7 覆盖采样抗锯齿（CSAA）

NVIDIA的优化技术：
- 分离覆盖采样和颜色/深度采样
- 16×覆盖配合4×颜色/深度
- 减少内存带宽需求

### 3.2.8 时间抗锯齿（TAA）

利用时间域的信息：
1. 每帧使用不同的采样偏移（jittering）
2. 将多帧结果进行时间积累
3. 使用运动向量处理动态场景

时间积累公式：
$$color_{new} = \alpha \cdot color_{current} + (1-\alpha) \cdot color_{history}$$

其中 $\alpha$ 通常为 0.1-0.2。

### 3.2.9 形态学抗锯齿（MLAA/FXAA/SMAA）

后处理抗锯齿技术：
1. **边缘检测**：识别几何边界
2. **模式匹配**：确定边缘形状
3. **混合**：根据模式进行像素混合

FXAA的亮度边缘检测：
$$edge = |L_N - L_S| + |L_E - L_W| > threshold$$

其中 $L$ 表示像素亮度。

## 3.3 现代GPU光栅化管线

### 3.3.1 GPU架构概述

现代GPU采用大规模并行架构：
- **流多处理器（SM）**：独立的计算单元
- **SIMT执行模型**：单指令多线程
- **Warp/Wavefront**：32/64线程的执行组

### 3.3.2 图元装配（Primitive Assembly）

将顶点组装成图元：
1. 索引缓冲读取
2. 图元拓扑解释（点、线、三角形）
3. 图元剔除（背面、视锥体外）

背面剔除：
$$\mathbf{n} \cdot \mathbf{v} = (v_1 - v_0) \times (v_2 - v_0) \cdot \mathbf{view} > 0$$

### 3.3.3 图元分配（Primitive Distribution）

将图元分配到屏幕分块：
1. 计算图元的屏幕空间包围盒
2. 确定覆盖的分块列表
3. 将图元引用添加到分块队列

分块大小权衡：
- 小分块：更好的负载均衡，更多的管理开销
- 大分块：更少的重复工作，可能的负载不均

### 3.3.4 片段生成与调度

每个分块独立处理：
1. 从队列读取图元
2. 生成片段（2×2像素块为单位）
3. 调度到着色单元

2×2像素块（Quad）的重要性：
- 计算屏幕空间导数（ddx、ddy）
- 纹理LOD计算
- 保证SIMD执行效率

### 3.3.5 深度缓冲压缩

减少带宽需求的关键技术：

#### 差分压缩
对于平面区域，存储基准值和差分：
$$z_{compressed} = z_{base} + \Delta z_x \cdot x + \Delta z_y \cdot y$$

#### 深度范围压缩
存储块的最小/最大值和相对偏移：
$$z_{normalized} = \frac{z - z_{min}}{z_{max} - z_{min}}$$

### 3.3.6 渲染输出单元（ROP）

负责最终的像素操作：
1. 深度测试
2. 模板测试
3. 混合操作
4. 写入帧缓冲

原子操作保证：
- 同一像素的操作串行化
- 不同像素可以并行

### 3.3.7 内存层次结构

优化的缓存设计：
1. **L1缓存**：纹理缓存、常量缓存
2. **L2缓存**：统一缓存，所有单元共享
3. **帧缓冲缓存**：专用于ROP操作

带宽优化技术：
- **Delta色彩压缩**：存储与参考值的差
- **快速清除**：标记而非实际写入
- **事务消除**：检测并跳过冗余写入

### 3.3.8 可编程管线扩展

#### 网格着色器（Mesh Shader）
新一代几何管线：
- 替代传统的顶点/几何着色器
- 支持GPU生成几何体
- 更灵活的图元剔除

#### 可变率着色（VRS）
允许不同区域使用不同的着色率：
- 1×1、1×2、2×2、4×4等
- 基于内容的自适应
- 注视点渲染优化

### 3.3.9 光线追踪硬件集成

现代GPU集成了光线追踪单元：
- **RT Core**：硬件加速的BVH遍历
- **光栅化与光追混合**：主要场景用光栅化，反射/阴影用光追
- **时间去噪**：利用TAA框架降噪

## 本章小结

光栅化是将连续几何转换为离散像素的核心过程。本章涵盖了：

**关键概念：**
- 三角形离散化的数学基础：边函数、重心坐标
- 透视正确插值：$\frac{1}{w}$ 的线性插值
- 深度缓冲与可见性：Z-Buffer算法及其优化
- 抗锯齿理论：采样定理与各种AA技术
- GPU管线架构：从图元到像素的并行处理

**重要公式：**
- 边函数：$E(\mathbf{p}) = (\mathbf{p} - \mathbf{v}_0) \times (\mathbf{v}_1 - \mathbf{v}_0)$
- 重心坐标：$\mathbf{p} = \alpha \mathbf{v}_0 + \beta \mathbf{v}_1 + \gamma \mathbf{v}_2$
- 透视插值：$attr = \frac{\sum \frac{\alpha_i \cdot attr_i}{w_i}}{\sum \frac{\alpha_i}{w_i}}$
- 深度映射：$z_{ndc} = \frac{f+n}{f-n} + \frac{2fn}{f-n} \cdot \frac{1}{z_{eye}}$

**性能考虑：**
- 分块光栅化减少overdraw
- Early-Z避免无用着色
- 压缩技术降低带宽需求
- SIMT执行模型的并行效率

## 练习题

### 基础题

**3.1 边函数计算**
给定三角形顶点 $\mathbf{v}_0 = (0, 0)$, $\mathbf{v}_1 = (4, 0)$, $\mathbf{v}_2 = (2, 3)$，计算点 $\mathbf{p} = (2, 1)$ 的三个边函数值，并判断该点是否在三角形内部。

*提示：注意顶点的顺序和边函数的符号。*

<details>
<summary>答案</summary>

计算三个边函数：
- $E_{01}(\mathbf{p}) = (2-0)(0-0) - (1-0)(4-0) = 0 - 4 = -4$
- $E_{12}(\mathbf{p}) = (2-4)(3-0) - (1-0)(2-4) = -6 - (-2) = -4$
- $E_{20}(\mathbf{p}) = (2-2)(0-3) - (1-3)(0-2) = 0 - 4 = -4$

由于所有边函数值都为负，说明三角形顶点是顺时针排列。对于顺时针排列，点在内部的条件是所有边函数值都小于等于0，因此点 $(2,1)$ 在三角形内部。

验证：可以计算重心坐标 $\alpha = \beta = \gamma = 1/3$，均为正值，确认点在内部。
</details>

**3.2 重心坐标插值**
三角形三个顶点的颜色分别为红色 $(1,0,0)$、绿色 $(0,1,0)$ 和蓝色 $(0,0,1)$。如果某点的重心坐标为 $(\alpha, \beta, \gamma) = (0.5, 0.3, 0.2)$，计算该点的插值颜色。

*提示：直接应用重心坐标的定义。*

<details>
<summary>答案</summary>

使用重心坐标进行线性插值：
$$\mathbf{color} = \alpha \cdot \mathbf{c}_0 + \beta \cdot \mathbf{c}_1 + \gamma \cdot \mathbf{c}_2$$
$$= 0.5 \cdot (1,0,0) + 0.3 \cdot (0,1,0) + 0.2 \cdot (0,0,1)$$
$$= (0.5, 0, 0) + (0, 0.3, 0) + (0, 0, 0.2)$$
$$= (0.5, 0.3, 0.2)$$

因此该点的颜色为 RGB = $(0.5, 0.3, 0.2)$。
</details>

**3.3 透视正确插值**
在屏幕空间，三角形顶点的深度值（$1/w$）分别为 0.5、0.25 和 0.125。某点的重心坐标为 $(0.4, 0.4, 0.2)$。如果顶点的纹理坐标分别为 $(0,0)$、$(1,0)$ 和 $(0.5,1)$，计算该点的透视正确纹理坐标。

*提示：先插值 $1/w$，再进行透视除法。*

<details>
<summary>答案</summary>

首先插值 $1/w$：
$$\frac{1}{w} = 0.4 \times 0.5 + 0.4 \times 0.25 + 0.2 \times 0.125 = 0.2 + 0.1 + 0.025 = 0.325$$

然后计算每个分量的权重：
$$\text{weight}_0 = \frac{0.4 \times 0.5}{0.325} = \frac{0.2}{0.325} = \frac{8}{13}$$
$$\text{weight}_1 = \frac{0.4 \times 0.25}{0.325} = \frac{0.1}{0.325} = \frac{4}{13}$$
$$\text{weight}_2 = \frac{0.2 \times 0.125}{0.325} = \frac{0.025}{0.325} = \frac{1}{13}$$

最后插值纹理坐标：
$$u = \frac{8}{13} \times 0 + \frac{4}{13} \times 1 + \frac{1}{13} \times 0.5 = \frac{4.5}{13} \approx 0.346$$
$$v = \frac{8}{13} \times 0 + \frac{4}{13} \times 0 + \frac{1}{13} \times 1 = \frac{1}{13} \approx 0.077$$

透视正确的纹理坐标为 $(0.346, 0.077)$。
</details>

**3.4 MSAA覆盖计算**
使用4×MSAA，采样点位置为像素中心偏移 $(-0.25, -0.25)$、$(0.25, -0.25)$、$(-0.25, 0.25)$ 和 $(0.25, 0.25)$。如果三角形边界恰好通过像素中心（从左下到右上的对角线），计算该像素的覆盖率。

*提示：判断每个采样点相对于边界的位置。*

<details>
<summary>答案</summary>

三角形边界是从左下到右上的对角线，可以表示为：$y = x$

对于每个采样点，检查是否在边界下方（假设三角形在边界下方）：
1. $(-0.25, -0.25)$：$-0.25 < -0.25$ 不成立，不被覆盖
2. $(0.25, -0.25)$：$-0.25 < 0.25$ 成立，被覆盖
3. $(-0.25, 0.25)$：$0.25 < -0.25$ 不成立，不被覆盖
4. $(0.25, 0.25)$：$0.25 < 0.25$ 不成立，不被覆盖

覆盖率 = 1/4 = 25%

注意：如果三角形在边界上方，则采样点1和3会被覆盖，覆盖率为50%。
</details>

### 挑战题

**3.5 保守光栅化**
设计一个保守光栅化算法，确保所有与三角形有任何重叠的像素都被标记。描述你的算法并分析其与标准光栅化的差异。考虑：如何扩展三角形边界？如何处理极小的三角形？

*提示：考虑将三角形边界向外扩展半个像素。*

<details>
<summary>答案</summary>

保守光栅化算法设计：

1. **边界扩展方法**：
   - 将每条边沿法线方向向外扩展 $\frac{\sqrt{2}}{2}$ 个像素（最坏情况下的像素对角线长度）
   - 边函数修改：$E'(p) = E(p) - \frac{\sqrt{2}}{2} \cdot ||\mathbf{n}||$

2. **实现步骤**：
   ```
   for each edge (v0, v1):
       normal = perpendicular(v1 - v0)
       offset = 0.5 * sqrt(2) * normalize(normal)
       expanded_edge = translate edge by offset
   ```

3. **极小三角形处理**：
   - 如果三角形面积小于一个像素，至少光栅化其质心所在的像素
   - 使用包围球测试：如果像素中心到三角形的距离小于 $\frac{\sqrt{2}}{2}$，则光栅化

4. **优化考虑**：
   - 使用分离轴定理进行精确的像素-三角形相交测试
   - 对于轴对齐的边，扩展可以简化为0.5像素

5. **应用场景**：
   - 体素化
   - 碰撞检测
   - 阴影体生成
</details>

**3.6 自适应超采样**
设计一个自适应超采样系统，只在需要的地方（如边缘）使用高采样率。你的系统应该包括：边缘检测标准、采样模式选择、以及性能与质量的权衡分析。

*提示：可以基于深度或颜色的梯度来检测边缘。*

<details>
<summary>答案</summary>

自适应超采样系统设计：

1. **边缘检测标准**：
   ```
   edge_score = max(
       |depth_center - depth_neighbor| / depth_center,
       |color_center - color_neighbor|,
       |normal_center · normal_neighbor - 1|
   )
   ```

2. **采样策略分级**：
   - Level 0 (1×): edge_score < 0.1
   - Level 1 (4×): 0.1 ≤ edge_score < 0.3
   - Level 2 (8×): 0.3 ≤ edge_score < 0.6
   - Level 3 (16×): edge_score ≥ 0.6

3. **实现流程**：
   - Pass 1: 以1×采样率渲染，同时输出G-buffer
   - Analysis: 分析G-buffer，标记需要超采样的像素
   - Pass 2: 对标记的像素进行超采样
   - Resolve: 合并结果

4. **优化技术**：
   - 时间复用：结合TAA，减少当前帧的采样需求
   - 预测：基于前一帧的边缘信息预测当前帧
   - 分块处理：以2×2或4×4块为单位决定采样率

5. **性能分析**：
   - 最佳情况：大部分平滑区域，接近1×性能
   - 最坏情况：全是边缘，退化为完全超采样
   - 典型场景：20-40%的像素需要超采样，性能提升2-3倍
</details>

**3.7 深度缓冲精度优化**
推导对数深度缓冲的数学公式，并分析其相对于标准深度缓冲的精度分布。实现一个深度值编码/解码方案，在24位定点数中最大化可用精度。

*提示：考虑人眼对近处细节的敏感度。*

<details>
<summary>答案</summary>

1. **对数深度推导**：
   
   标准深度：$z_{std} = \frac{f+n}{f-n} - \frac{2fn}{(f-n)z}$
   
   对数深度：$z_{log} = \frac{\log(z/n)}{\log(f/n)}$
   
   精度分析：
   - 标准深度：$\frac{dz_{std}}{dz} = \frac{2fn}{(f-n)z^2}$（随z²下降）
   - 对数深度：$\frac{dz_{log}}{dz} = \frac{1}{z\log(f/n)}$（随z线性下降）

2. **24位编码方案**：
   ```
   encode(z_eye):
       // 使用伪对数编码
       if z_eye < split_distance:
           // 近处使用线性
           encoded = (z_eye - n) / (split - n) * 0.5
       else:
           // 远处使用对数
           encoded = 0.5 + 0.5 * log(z_eye/split) / log(f/split)
       return uint24(encoded * (2^24 - 1))
   ```

3. **精度分布优化**：
   - 分割点选择：$split = \sqrt{nf}$（几何平均）
   - 近处精度：~0.01mm at 1m
   - 远处精度：~1m at 1000m

4. **实际考虑**：
   - 反向Z + 浮点：利用浮点数的指数特性
   - W缓冲：直接存储线性深度1/w
   - 多级深度：近景和远景使用独立缓冲
</details>

**3.8 GPU分块大小优化**
分析不同分块大小（8×8, 16×16, 32×32）对GPU光栅化性能的影响。考虑：缓存命中率、负载均衡、几何复杂度的影响。设计一个实验来确定特定场景的最优分块大小。

*提示：考虑三角形大小分布和屏幕空间局部性。*

<details>
<summary>答案</summary>

1. **理论分析**：

   **8×8分块**：
   - 优点：细粒度负载均衡，小三角形效率高
   - 缺点：管理开销大，大三角形跨越多个块
   
   **16×16分块**：
   - 优点：平衡的选择，适合中等大小三角形
   - 缺点：某些场景可能不够灵活
   
   **32×32分块**：
   - 优点：管理开销小，大三角形效率高
   - 缺点：负载不均衡风险，小三角形浪费

2. **性能模型**：
   ```
   Cost = N_tiles × (C_setup + N_prims × C_raster + N_pixels × C_shade)
   
   其中：
   - N_tiles = ceil(W/tile_size) × ceil(H/tile_size)
   - N_prims = avg_prims_per_tile（与分块大小相关）
   - N_pixels = tile_size²（实际着色的像素可能更少）
   ```

3. **实验设计**：
   ```
   for tile_size in [8, 16, 32]:
       for scene in [many_small_tris, few_large_tris, mixed]:
           measure:
               - Frame time
               - Tile occupancy
               - Cache miss rate
               - Warp divergence
   ```

4. **自适应策略**：
   - 基于场景统计动态选择
   - 混合分块：不同区域使用不同大小
   - 预测模型：基于前几帧的统计信息

5. **实际建议**：
   - UI渲染：8×8（many small triangles）
   - 游戏场景：16×16（平衡选择）
   - CAD/建筑：32×32（大型三角形）
</details>

## 常见陷阱与错误（Gotchas）

### 1. 精度相关问题

**浮点精度导致的裂缝**
- **问题**：相邻三角形的共享边在光栅化时可能产生裂缝
- **原因**：浮点运算的舍入误差
- **解决**：使用定点数运算，确保共享顶点的坐标完全相同

**深度精度不足**
- **问题**：Z-fighting，远处物体深度分辨率低
- **原因**：透视投影的非线性深度分布
- **解决**：调整near/far平面，使用对数深度或反向Z

### 2. 插值错误

**屏幕空间线性插值**
- **问题**：纹理扭曲，光照不正确
- **原因**：忘记进行透视校正
- **解决**：始终使用 $1/w$ 进行插值权重计算

**属性插值溢出**
- **问题**：颜色值超出[0,1]范围
- **原因**：重心坐标计算错误或数值精度问题
- **解决**：验证重心坐标和为1，添加范围检查

### 3. 性能陷阱

**过度绘制（Overdraw）**
- **问题**：同一像素被多次着色
- **原因**：绘制顺序不当，缺少早期剔除
- **解决**：前向后渲染不透明物体，使用Early-Z

**小三角形问题**
- **问题**：GPU利用率低
- **原因**：小于2×2像素的三角形导致quad利用率低
- **解决**：使用LOD，合并小三角形

### 4. 抗锯齿相关

**MSAA与透明度**
- **问题**：Alpha-tested几何体边缘仍有锯齿
- **原因**：MSAA只对几何边缘有效，不处理着色器discard
- **解决**：使用Alpha to Coverage或专门的透明度AA

**TAA鬼影**
- **问题**：移动物体出现拖尾
- **原因**：历史帧权重过高或运动向量不准确
- **解决**：降低历史帧权重，改进运动向量计算

### 5. GPU特定问题

**Warp发散**
- **问题**：性能显著下降
- **原因**：同一warp内的线程执行不同分支
- **解决**：排序绘制调用，减少动态分支

**纹理缓存未命中**
- **问题**：带宽瓶颈
- **原因**：纹理访问模式随机，mipmap选择不当
- **解决**：改善UV布局，正确计算LOD

### 6. 调试技巧

**视觉化调试**
```
// 可视化重心坐标
color = vec3(alpha, beta, gamma);

// 可视化mipmap级别
color = heat_map(mipmap_level);

// 可视化overdraw
color = vec3(overdraw_count / max_overdraw);
```

**性能分析要点**
- 使用GPU profiler识别瓶颈
- 监控各阶段的吞吐量
- 检查缓存命中率

## 最佳实践检查清单

### 光栅化设计审查

#### 几何处理
- [ ] 三角形顶点按一致顺序（通常逆时针）
- [ ] 共享顶点使用索引缓冲
- [ ] 避免退化三角形（面积接近0）
- [ ] 合理的三角形大小（避免过小）

#### 精度管理
- [ ] 定点数用于光栅化坐标
- [ ] 适当的子像素精度（通常8-16位）
- [ ] Near/far平面合理设置
- [ ] 深度缓冲格式选择得当

#### 性能优化
- [ ] 实施背面剔除
- [ ] 启用Early-Z（避免禁用它的操作）
- [ ] 合理的绘制顺序（不透明物体前到后）
- [ ] 批处理相似的绘制调用

#### 抗锯齿策略
- [ ] 根据目标平台选择AA方法
- [ ] MSAA采样模式优化
- [ ] TAA的运动向量正确
- [ ] 后处理AA作为备选方案

#### 内存与带宽
- [ ] 深度缓冲压缩启用
- [ ] 颜色缓冲压缩启用
- [ ] 合理的渲染目标格式
- [ ] 避免不必要的缓冲清除

#### 着色器最佳实践
- [ ] 避免着色器中的discard（影响Early-Z）
- [ ] 减少动态分支
- [ ] 利用插值器硬件
- [ ] 正确的导数计算（维持2×2 quad）

#### 现代特性利用
- [ ] VRS用于性能优化
- [ ] Mesh shader用于几何优化
- [ ] 硬件光追的选择性使用
- [ ] 多分辨率渲染技术

#### 调试与验证
- [ ] 无渲染错误（裂缝、闪烁）
- [ ] 性能指标达标
- [ ] 内存使用合理
- [ ] 支持必要的调试可视化

### 代码质量
- [ ] 光栅化参数可配置
- [ ] 适当的错误处理
- [ ] 性能计数器集成
- [ ] 清晰的管线状态管理
